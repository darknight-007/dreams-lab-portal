<div class="tutorial-container">
    <div class="tutorial-text">
        <h2>Multi-View Geometry Fundamentals</h2>
        <p>
            Understanding the geometric relationships between multiple views of a 3D scene is fundamental to computer vision. 
            We'll explore the key concepts of epipolar geometry and the matrices that describe these relationships.
        </p>

        <h3>Key Concepts</h3>
        <ul>
            <li>Epipolar Geometry</li>
            <li>Fundamental Matrix (F)</li>
            <li>Essential Matrix (E)</li>
            <li>Camera Calibration Matrix (K)</li>
        </ul>

        <h3>Epipolar Geometry</h3>
        <p>
            When a point X in 3D space is viewed from two different camera positions, the following relationship exists:
        </p>
        <div style="text-align: left;">
            \[x'^T F x = 0\]
            where:
            <ul>
                <li>\(x, x'\) are corresponding points in two images</li>
                <li>\(F\) is the fundamental matrix</li>
            </ul>
        </div>

        <h3>Essential Matrix</h3>
        <p>
            The essential matrix E relates normalized image coordinates:
        </p>
        <div style="text-align: left;">
            \[E = K'^T F K\]
            \[E = [t]_{\times} R\]
            where:
            <ul>
                <li>\(K\) is the camera calibration matrix</li>
                <li>\(R\) is the rotation matrix</li>
                <li>\([t]_{\times}\) is the skew-symmetric matrix of translation</li>
            </ul>
        </div>

        <h3>Camera Calibration Matrix</h3>
        <div style="text-align: left;">
            \[K = \begin{bmatrix} 
            f_x & s & c_x \\
            0 & f_y & c_y \\
            0 & 0 & 1
            \end{bmatrix}\]
            where:
            <ul>
                <li>\(f_x, f_y\) are focal lengths in pixels</li>
                <li>\(s\) is the skew</li>
                <li>\(c_x, c_y\) are the principal points</li>
            </ul>
        </div>
    </div>

    <!-- Replace the 2D SVG with a 3D Three.js canvas -->
    <div class="tutorial-viz">
        <div id="three-container"></div>
    </div>
</div>

<!-- Add controls for 3D visualization -->
<div class="two-column-container">
    <div class="slider-column">
        <h2>Camera Parameters</h2>
        <div class="container">
            <label for="focalLength">Focal Length (mm): <span id="focalLengthLabel"></span></label>
            <input type="range" id="focalLength" min="5" max="50" step="0.1" value="35" 
                oninput="window.updateVisualization()">
            <input type="number" id="focalLengthValue" value="35" step="0.1" 
                onchange="window.updateVisualization()">
        </div>
        
        <div class="container">
            <label for="baseline">Baseline (mm): <span id="baselineLabel"></span></label>
            <input type="range" id="baseline" min="50" max="500" step="1" value="200" oninput="updateVisualization()">
            <input type="number" id="baselineValue" value="200" step="1" onchange="updateVisualization()">
        </div>

        <div class="container">
            <label for="pointDepth">Point Depth (m): <span id="pointDepthLabel"></span></label>
            <input type="range" id="pointDepth" min="1" max="10" step="0.1" value="3" oninput="updateVisualization()">
            <input type="number" id="pointDepthValue" value="3" step="0.1" onchange="updateVisualization()">
        </div>
    </div>

    <div class="results-column">
        <h2>Computed Matrices</h2>
        <div id="fundamentalMatrix">Fundamental Matrix (F):</div>
        <div id="essentialMatrix">Essential Matrix (E):</div>
        <div id="calibrationMatrix">Calibration Matrix (K):</div>
    </div>
</div>

<!-- Replace the existing Three.js script tags with these -->
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, controls;
let camera1, camera2, point3D;
let epipolarLine1, epipolarLine2;

// Initialize matrices with default values
let m = {
    essential: [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
    ],
    fundamental: [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
    ],
    camera: [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0]
    ]
};

function initScene() {
    // Initialize Three.js scene
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    
    const container = document.getElementById('three-container');
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // Add cameras to scene
    camera1 = createCameraModel();
    camera2 = createCameraModel();
    scene.add(camera1);
    scene.add(camera2);

    // Add 3D point
    const geometry = new THREE.SphereGeometry(0.1);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    point3D = new THREE.Mesh(geometry, material);
    scene.add(point3D);

    // Add epipolar lines
    const lineGeometry = new THREE.BufferGeometry();
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    epipolarLine1 = new THREE.Line(lineGeometry, lineMaterial);
    epipolarLine2 = new THREE.Line(lineGeometry, lineMaterial);
    scene.add(epipolarLine1);
    scene.add(epipolarLine2);

    // Set up camera position
    camera.position.z = 5;
    camera.position.y = 2;
    camera.lookAt(0, 0, 0);

    // Add orbit controls
    controls = new OrbitControls(camera, renderer.domElement);
    
    animate();
}

function createCameraModel() {
    const cameraGroup = new THREE.Group();
    
    // Create camera body
    const bodyGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.3);
    const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    
    // Create camera frustum
    const frustumGeometry = new THREE.ConeGeometry(0.3, 0.5, 4);
    const frustumMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x404040, 
        transparent: true, 
        opacity: 0.5 
    });
    const frustum = new THREE.Mesh(frustumGeometry, frustumMaterial);
    frustum.rotation.x = Math.PI / 2;
    frustum.position.z = 0.4;
    
    cameraGroup.add(body);
    cameraGroup.add(frustum);
    
    return cameraGroup;
}

function updateVisualization() {
    const focalLength = parseFloat(document.getElementById('focalLength').value);
    const baseline = parseFloat(document.getElementById('baseline').value) / 1000;
    const pointDepth = parseFloat(document.getElementById('pointDepth').value);

    // Update camera positions
    camera1.position.set(-baseline/2, 0, 0);
    camera2.position.set(baseline/2, 0, 0);
    
    // Update 3D point position
    point3D.position.set(0, 0, -pointDepth);

    // Calculate and update matrices
    updateMatrices(focalLength, baseline, pointDepth);
    
    // Update epipolar lines
    updateEpipolarLines();
}

function updateMatrices(focalLength, baseline, depth) {
    // Calculate calibration matrix
    const K = [
        [focalLength, 0, 0],
        [0, focalLength, 0],
        [0, 0, 1]
    ];

    // Calculate essential matrix
    const E = [
        [0, -baseline, 0],
        [baseline, 0, 0],
        [0, 0, 0]
    ];

    // Calculate fundamental matrix (simplified)
    const F = multiplyMatrices(
        invertMatrix(K),
        multiplyMatrices(E, invertMatrix(K))
    );

    // Display matrices with proper LaTeX formatting
    document.getElementById('calibrationMatrix').innerHTML = 
        'Calibration Matrix (K): ' + formatMatrix(K);
    document.getElementById('essentialMatrix').innerHTML = 
        'Essential Matrix (E): ' + formatMatrix(E);
    document.getElementById('fundamentalMatrix').innerHTML = 
        'Fundamental Matrix (F): ' + formatMatrix(F);

    // Trigger MathJax to reprocess the page
    if (window.MathJax) {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}

// Matrix helper functions
function multiplyMatrices(a, b) {
    // Implementation is missing
    const result = Array(a.length).fill().map(() => Array(b[0].length).fill(0));
    for (let i = 0; i < a.length; i++) {
        for (let j = 0; j < b[0].length; j++) {
            for (let k = 0; k < b.length; k++) {
                result[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    return result;
}

function invertMatrix(m) {
    // Implementation is missing - here's a simple 3x3 matrix inversion
    const det = m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
              - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
              + m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

    const invDet = 1 / det;
    
    return [
        [(m[1][1] * m[2][2] - m[1][2] * m[2][1]) * invDet, (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * invDet, (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * invDet],
        [(m[1][2] * m[2][0] - m[1][0] * m[2][2]) * invDet, (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * invDet, (m[0][2] * m[1][0] - m[0][0] * m[1][2]) * invDet],
        [(m[1][0] * m[2][1] - m[1][1] * m[2][0]) * invDet, (m[0][1] * m[2][0] - m[0][0] * m[2][1]) * invDet, (m[0][0] * m[1][1] - m[0][1] * m[1][0]) * invDet]
    ];
}

function formatMatrix(matrix) {
    // Format matrix for LaTeX display with proper number formatting
    return '\\[\\begin{bmatrix} ' + 
        matrix.map(row => 
            row.map(val => Number(val).toFixed(3)).join(' & ')
        ).join(' \\\\ ') +
        ' \\end{bmatrix}\\]';
}

// Add input handlers if needed
function oninput(event) {
    // Handle input changes here
    updateMatrices({
        essential: m.essential,
        fundamental: m.fundamental,
        camera: m.camera
    });
}

// Initialize when page loads
window.addEventListener('load', () => {
    initScene();
    updateVisualization();
});

function updateEpipolarLines() {
    // Create points for epipolar lines
    const linePoints = new Float32Array([
        -2, 0, 0,
        2, 0, 0
    ]);
    
    epipolarLine1.geometry.setAttribute('position', new THREE.BufferAttribute(linePoints, 3));
    epipolarLine2.geometry.setAttribute('position', new THREE.BufferAttribute(linePoints, 3));
    
    // Update line positions based on cameras
    epipolarLine1.position.copy(camera1.position);
    epipolarLine2.position.copy(camera2.position);
}

// Add after scene initialization
window.addEventListener('resize', () => {
    const container = document.getElementById('three-container');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
});

// Make functions available to global scope
window.updateVisualization = updateVisualization;
</script> 

<!-- Add this before your other scripts -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['\\(','\\)']],
      displayMath: [['\\[','\\]']],
      processEscapes: true
    }
  });
</script> 

<!-- Add this CSS to your HTML file -->
<style>
.tutorial-container {
    display: flex;
    gap: 20px;
    margin: 20px;
}

.tutorial-text {
    flex: 1;
    max-width: 60%;
}

.tutorial-viz {
    flex: 1;
    min-width: 40%;
}

#three-container {
    width: 100%;
    height: 400px;  /* Adjust this value as needed */
    background: #f0f0f0;
    border: 1px solid #ccc;
}

.two-column-container {
    display: flex;
    gap: 20px;
    margin: 20px;
}

.slider-column, .results-column {
    flex: 1;
}

.container {
    margin-bottom: 15px;
}

input[type="range"] {
    width: 100%;
}

input[type="number"] {
    width: 80px;
}
</style> 