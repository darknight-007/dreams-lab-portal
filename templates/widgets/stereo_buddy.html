<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stereo Camera Configurator</title>
    <style>
        .loading-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            margin: 20px 0;
        }

        .loading-text {
            font-size: 18px;
            font-weight: bold;
            margin-left: 10px;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #ccc;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <style>
        .container button {
            font-size: 20px;
            font-weight: bold;
            padding: 15px 30px;
            color: #fff;
            background-color: #007bff; /* Attractive blue color */
            border: none;
            border-radius: 8px; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow */
            cursor: pointer;
            transition: all 0.3s ease; /* Smooth transition for hover effect */
        }

        .container button:hover {
            background-color: #0056b3; /* Darker blue on hover */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15); /* Stronger shadow on hover */
            transform: translateY(-2px); /* Slight lift on hover */
        }

        .container button:active {
            transform: translateY(0); /* Reset lift when clicked */
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1); /* Reduce shadow when clicked */
        }
    </style>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            width: 100%;
            max-width: 1200px;  /* Optional: limit maximum width */
            margin: 0 auto;     /* Center content */
            padding: 20px;      /* Add padding */
        }

        .column {
            flex: 1;
            margin: 10px;
            display: flex;
            flex-direction: column;
        }

        .widget {
            max-width: 100%;
            overflow-y: auto;
        }

        .svg-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        svg {
            width: 100%;
            height: 100%;
            border: 1px solid #ccc;
        }

        .results {
            margin-top: 20px;
        }

        .results div {
            margin-bottom: 10px;
        }

        .container {
            margin-bottom: 15px;
        }

        label span {
            font-weight: bold;
            margin-left: 5px;
        }

        input[type="number"] {
            width: 100px;
        }
    </style>
    <style>
    /* Combined container styles */
    .container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
    }

    .container button {
        font-size: 20px;
        font-weight: bold;
        padding: 15px 30px;
        color: #fff;
        background-color: #007bff;
        border: none;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: all 0.3s ease;
    }

    /* Combined input styles */
    .container label {
        flex: 1;
        margin-right: 10px;
        font-size: 14px;
        font-weight: bold;
    }

    .container input[type="range"] {
        flex: 2;
        margin-right: 10px;
    }

    .container input[type="number"] {
        flex: 1;
        width: 60px;
    }
</style>
<style>
    .debug-container {
        margin-top: 20px;
        padding: 10px;
        border: 1px solid #ccc;
        background-color: #f9f9f9;
        font-family: monospace;
        font-size: 14px;
        max-height: 200px;
        overflow-y: auto;
    }

    #debugOutput {
        white-space: pre-wrap;
    }
</style>
    <style>
    /* Add styling for the wrap figure */
    .wrap-figure {
        float: right;
        width: 45%; /* Adjust width for the figure */
        margin: 0 0 10px 20px; /* Add spacing between the text and figure */
    }

    .wrap-figure svg {
        width: 100%; /* SVG scales to fit within the figure container */
        height: auto; /* Maintain aspect ratio */
        border: 1px solid #ccc; /* Optional border for clarity */
        display: block; /* Prevent inline SVG alignment issues */
    }

    .equation-text {
        text-align: justify;
    }
</style>
    <style>
    /* Flexbox container for two-column layout */
    .two-column-container {
        display: flex;
        gap: 20px;
        margin-top: 20px;
    }

    .slider-column {
        flex: 1;
        max-width: 50%;
    }

    .results-column {
        flex: 1;
        max-width: 50%;
        position: sticky;
        top: 20px;
    }

    /* Ensure proper scrolling for long content */
    .widget {
        overflow-y: auto;
        max-height: 100vh;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .tutorial-container,
        .two-column-container {
            flex-direction: column;
        }

        .tutorial-text,
        .tutorial-viz,
        .slider-column,
        .results-column {
            max-width: 100%;
        }

        .tutorial-viz {
            position: static;
            margin: 20px 0;
        }
    }
</style>
    <style>
    /* Remove duplicate style block and keep only one instance */
    .dropdown-button-container {
        display: flex;
        align-items: center;
        gap: 20px;
    }

    .dropdown-button-container select {
        flex: 1;
        max-width: 300px;
    }

    .dropdown-button-container button {
        flex: 0;
        padding: 10px 20px;
        font-size: 16px;
        font-weight: bold;
        color: #fff;
        background-color: #007bff;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .dropdown-button-container button:hover {
        background-color: #0056b3;
    }
</style>
  <script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
            fontCache: 'global'
        }
    };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-chtml.min.js"></script>

    <style>
        /* Increase font size for tutorial text and equations */
        .equation-text {
            font-size: 1.2em;
            line-height: 1.6;
        }

        .equation-text p, .equation-text ul {
            font-size: 1.1em;
        }

        /* Increase size of MathJax equations */
        .MathJax {
            font-size: 120% !important;
        }
    </style>

    <style>
        .tutorial-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            width: 100%;
            clear: both;      /* Clear float after tutorial */
        }

        .tutorial-text {
            flex: 1;
            max-width: 50%;
        }

        .tutorial-viz {
            flex: 1;
            max-width: 50%;
        }
    </style>

    <style>
        /* Fix widget visibility */
        .widget {
            width: 100%;
            margin: 20px 0;
            display: block;  /* Ensure widget is displayed */
            clear: both;     /* Clear any floats */
        }

        /* Ensure column layout works */
        .column {
            flex: 1;
            margin: 10px;
            display: flex;
            flex-direction: column;
            min-height: 200px;  /* Give minimum height */
        }

        /* Fix two-column container layout */
        .two-column-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            width: 100%;      /* Ensure full width */
            clear: both;      /* Clear any floats */
        }

        .slider-column,
        .results-column {
            flex: 1;
            min-width: 300px; /* Ensure minimum width */
        }
    </style>

</head>
<body>
<div class="widget">
    <h1>Stereo Camera Configurator and Tutorial</h1>

    <!-- New two-column container -->
    <div class="tutorial-container">
        <!-- Left column: Text content -->
        <div class="tutorial-text">
            <h2>Background</h2>
            <p>
                We formalize the configuration and parameter optimization of a multi-camera system for planetary surface mapping, such as Martian or Lunar terrain. This includes a stereo camera setup and derives parameter relationships, extending to multi-camera setups.
            </p>

            <h2>Stereo Camera Configuration</h2>
            <p>The stereo camera parameters include:</p>
            <ul>
                <li>\(f_{\text{mm}}\): Focal length in mm</li>
                <li>\(\theta\): Pixel angular resolution (rad/pixel)</li>
                <li>\(\phi_H\): Horizontal Field of View (FoV)</li>
                <li>\(z\): Depth of the object</li>
                <li>\(f_{\text{pixels}}\): Focal length in pixels</li>
                <li>\(B\): Baseline (distance between cameras) in meters</li>
                <li>\(d\): Disparity (pixels)</li>
                <li>\(\alpha\): Toe-in angle (radians)</li>
            </ul>

            <h3>Equations</h3>
            <p>The following key equations define the system's functionality:</p>

            <p>(1) Focal length in pixels:</p>
            <div style="text-align: left;">
                \[f_{\text{pixels}} = f_{\text{mm}} \cdot \frac{\text{Resolution}_{\text{horizontal}}}{\text{Detector Width}_{\text{mm}}}\]
            </div>

            <p>(2) Minimum distance for depth resolution:</p>
            <div style="text-align: left;">
                \[z_{\text{min}} = \frac{B}{2 \cdot \tan\left(\alpha + \frac{\phi_H}{2}\right)}\]
            </div>

            <p>(3) Pixel spatial resolution at distance \(z\):</p>
            <div style="text-align: left;">
                \[\Delta x = z \cdot \theta\]
            </div>

            <p>(4) Disparity at distance:</p>
            <div style="text-align: left;">
                \[d = f_{\text{pixels}} \cdot \frac{B}{z \cdot \cos\alpha}\]
            </div>

            <p>(5) Maximum distance for depth resolution:</p>
            <div style="text-align: left;">
                \[z_{\text{max}} = \frac{B}{\theta \cdot \cos\alpha}\]
            </div>

            <p>(6) Convergence point of the optical axes:</p>
            <div style="text-align: left;">
                \[z_{\text{convergence}} = \frac{B}{2 \cdot \tan(\alpha)}\]
            </div>
        </div>

        <!-- Right column: SVG visualization -->
        <div class="tutorial-viz">
            <svg id="cameraView" preserveAspectRatio="xMidYMid meet">
                <!-- Axis lines -->
                <line id="xAxis" stroke="black" stroke-width="2" />
                <line id="yAxis" stroke="black" stroke-width="2" />
                <!-- Axis labels -->
                <text id="xAxisLabel" text-anchor="middle" font-size="12"></text>
                <text id="yAxisLabel" text-anchor="middle" font-size="12"></text>
                <!-- Camera setup -->
                <polygon id="leftCameraFOV" fill="rgba(255, 0, 0, 0.6)"></polygon>
                <polygon id="rightCameraFOV" fill="rgba(0, 255, 0, 0.6)"></polygon>
                <line id="baselineLine" stroke="black" stroke-width="2" />
                <!-- Converging lines to object -->
                <line id="leftLineToObject" stroke="blue" stroke-width="2" />
                <line id="rightLineToObject" stroke="blue" stroke-width="2" />
                <!-- Object point -->
                <circle id="objectPoint" r="5" fill="black" />
            </svg>
        </div>
    </div>
</div>

<div class="column widget">
   <div class="two-column-container">
    <!-- Sliders Column -->
    <div class="slider-column">
        <h1>Stereo Camera Configurator</h1>
        <div class="container">
            <label for="sensorWidth">Sensor Width (mm): <span id="sensorWidthLabel"></span></label>
            <input type="range" id="sensorWidth" min="1" max="20" step="0.01" value="8.44" oninput="syncValues('sensorWidth')">
            <input type="number" id="sensorWidthValue" value="8.44" step="0.01"
                   onchange="syncValues('sensorWidth')">
        </div>
        <div class="container">
            <label for="focalLength">Focal Length (mm): <span id="focalLengthLabel"></span></label>
            <input type="range" id="focalLength" min="5" max="50" step="0.1" value="19.71" oninput="syncValues('focalLength')">
            <input type="number" id="focalLengthValue" value="19.71" step="0.1"
                   onchange="syncValues('focalLength')">
        </div>
        <div class="container">
            <label for="fieldOfView">Field of View (°): <span id="fieldOfViewLabel"></span></label>
            <input type="range" id="fieldOfView" min="10" max="120" step="0.01" value="25.5" oninput="syncValues('fieldOfView')">
            <input type="number" id="fieldOfViewValue" value="25.5" step="0.1"
                   onchange="syncValues('fieldOfView')">
        </div>
        <div class="container">
            <label for="baseline">Baseline (mm): <span id="baselineLabel"></span></label>
            <input type="range" id="baseline" min="50" max="500" step="0.1" value="290" oninput="syncValues('baseline')">
            <input type="number" id="baselineValue" value="290" step="1"
                   onchange="syncValues('baseline')">
        </div>

        <div class="container">
            <label for="toeInAngle">Toe-in Angle (°): <span id="toeInAngleLabel"></span></label>
            <input type="range" id="toeInAngle" min="0.1" max="15" step="0.001" value="1.25" oninput="syncValues('toeInAngle')">
            <input type="number" id="toeInAngleValue" value="1.25" step="0.001"
                   onchange="syncValues('toeInAngle')">
        </div>

        <div class="container">
            <label for="distance">Desired Convergence Distance (m): <span id="distanceLabel"></span></label>
            <input type="range" id="distance" min="0.5" max="50" step="0.01" oninput="syncValues('distance')">
            <input type="number" id="distanceValue" step="0.1"
                   onchange="syncValues('distance')">
        </div>
    </div>

    <!-- Results Column -->
    <div class="results-column">
        <h2>Calculated Results</h2>
        <div id="focalLengthPixels">Focal Length (px): 1234.56</div>
        <div id="disparity">Disparity: 45.67 px</div>
        <div id="zmin">Minimum Depth Resolution (zmin): 0.12 m</div>
        <div id="zmax">Maximum Depth Resolution (zmax): 10.23 m</div>
        <div id="convergencePoint">Convergence Point (zconvergence): -- m</div>
        <div id="depthResolution">Depth Resolution at convergence point: 0.0023 m</div>

    </div>
</div>
    <div class="rendered_images">
        <h2>Digital Twin</h2>

    </div>

<div class="dropdown-button-container">
    <!-- Dropdown for Rock Model -->
    <label for="rockModel"><strong>Select Rock Model:</strong></label>
    <select id="rockModel">

    </select>

    <!-- Button for Blender Scene Synthesis -->
        <button onclick="runBlender()">Run Blender Scene Synthesis</button>
</div>

    <div class="container" style="margin-top: 20px;">
    <button id="generateReportButton" onclick="generateBatchReport()">
        Generate Full Report
    </button>
</div>

     <div class="loading-container" id="loadingIndicator" style="display: none;">
        <div class="spinner"></div>
        <div class="loading-text">Computing...</div>
    </div>


<div class="rendered_images" id="renderedImagesContainer">
    <h2>Report Results</h2>
</div>

<div class="rendered_files" id="renderedFiles" style="display: none;">
    <h2>Download Generated Scene</h2>
    <div>
        <a id="blendFileLink" href="#" download="scene.blend">
            <button>Download Blender Scene (.blend)</button>
        </a>
    </div>
    <div>
        <a id="worldFileLink" href="#" download="scene.world">
            <button>Download Gazebo World (.world)</button>
        </a>
    </div>
</div>
    <div class="debug-container">
    <h2>Debug Messages</h2>
    <div id="debugOutput"></div>
</div>
</div>


<script type="text/javascript">
    async function loadModels() {
        const debugOutput = document.getElementById("debugOutput");
        try {
            const response = await fetch("/get_models/");
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const models = await response.json();

            const dropdown = document.getElementById("rockModel");
            if (!dropdown) {
                throw new Error("Rock model dropdown not found");
            }

            dropdown.innerHTML = "";
            models.forEach(model => {
                const option = document.createElement("option");
                option.value = model.path;
                option.textContent = model.name;
                dropdown.appendChild(option);
            });
        } catch (error) {
            console.error("Error loading models:", error);
            debugOutput.textContent = `Error loading models: ${error.message}`;
        }
    }

    async function generateBatchReport() {
        const debugOutput = document.getElementById("debugOutput");
        const renderedImagesContainer = document.getElementById("renderedImagesContainer");

        // Clear previous results
        renderedImagesContainer.innerHTML = "<h2>Report Results</h2>";
        debugOutput.textContent = "";

        try {
            // Show spinner
            document.getElementById("loadingIndicator").style.display = "flex";

            const response = await fetch("/generate_batch_report/", { method: "POST" });
            const result = await response.json();

            if (result.status === "completed") {
                debugOutput.textContent = "Full report generated successfully.";

                // Display generated images and results for each model
                result.report.forEach(modelResult => {
                    if (modelResult.status === "success") {
                        renderedImagesContainer.innerHTML += `
                            <div>
                                <h3>Model: ${modelResult.model}</h3>
                                <img src="${modelResult.images.left_camera}" alt="Left Camera Image" width="300" />
                                <img src="${modelResult.images.right_camera}" alt="Right Camera Image" width="300" />
                                <img src="${modelResult.images.disparity_map}" alt="Disparity Map" width="300" />
                                <img src="${modelResult.images.depth_map}" alt="Depth Map" width="300" />
                            </div>
                            <hr>
                        `;
                    } else {
                        renderedImagesContainer.innerHTML += `
                            <div>
                                <h3>Error with Model: ${modelResult.model}</h3>
                                <p>${modelResult.details}</p>
                            </div>
                            <hr>
                        `;
                    }
                });
            } else {
                debugOutput.textContent = "Error generating report: " + result.details;
            }
        } catch (error) {
            debugOutput.textContent = `Error: ${error}`;
        } finally {
            // Hide spinner
            document.getElementById("loadingIndicator").style.display = "none";
        }
    }

    async function runBlender() {
        const loadingIndicator = document.getElementById("loadingIndicator");
        const debugDiv = document.getElementById("debugOutput");
        const renderedImagesDiv = document.querySelector(".rendered_images");
        const renderedFilesDiv = document.getElementById("renderedFiles");

        try {
            // Clear previous results
            renderedImagesDiv.innerHTML = "<h2>Digital Twin</h2>";
            renderedFilesDiv.style.display = "none";
            debugDiv.textContent = "";

            // Show loading indicator
            loadingIndicator.style.display = "flex";

            const dropdown = document.getElementById("rockModel");
            const selectedModel = dropdown.options[dropdown.selectedIndex].value;

            // Debug message
            debugDiv.textContent = `Selected model: ${selectedModel}`;

            const data = {
                sensorWidth: parseFloat(document.getElementById("sensorWidth").value),
                focalLength: parseFloat(document.getElementById("focalLength").value),
                baseline: parseFloat(document.getElementById("baseline").value),
                distance: parseFloat(document.getElementById("distance").value),
                toeInAngle: parseFloat(document.getElementById("toeInAngle").value),
                selectedModel: selectedModel,
                modelPath: selectedModel,
            };

            const response = await fetch("/run_blender/", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(data),
            });

            const result = await response.json();

            if (result.status === "success") {
                debugDiv.textContent = "Blender script executed successfully.";

                // Add timestamp to prevent browser caching
                const timestamp = new Date().getTime();

                // Rendered Images with cache-busting
                renderedImagesDiv.innerHTML += `
                    <div>
                        <img src="/media/render_outputs/left_camera.png?t=${timestamp}" alt="Left Image" width="300" />
                        <img src="/media/render_outputs/right_camera.png?t=${timestamp}" alt="Right Image" width="300" />
                    </div>
                    <div>
                        <img src="/media/render_outputs/depth_map.png?t=${timestamp}" alt="Disparity Map" width="300" />
                        <img src="/media/render_outputs/disparity_map.png?t=${timestamp}" alt="Depth Map" width="300" />
                    </div>`;

                // Update download links with cache-busting
                document.getElementById("blendFileLink").href = `/media/render_outputs/scene.blend?t=${timestamp}`;
                document.getElementById("worldFileLink").href = `/media/render_outputs/scene.world?t=${timestamp}`;
                renderedFilesDiv.style.display = "block";
            } else {
                debugDiv.textContent = `Error: ${result.details}`;
            }
        } catch (error) {
            debugDiv.textContent = `Error executing Blender script: ${error}`;
        } finally {
            loadingIndicator.style.display = "none";
        }
    }

    loadModels();
</script>

<script>
    const scalingFactor = 50;

    // Global flag to prevent recursive updates
    let isUpdating = false;

    function initializeValues() {
        if (isUpdating) return;
        isUpdating = true;

        try {
            const baseline = parseFloat(document.getElementById('baseline').value) / 1000;
            const toeInDegrees = parseFloat(document.getElementById('toeInAngle').value);
            const toeInRadians = (toeInDegrees * Math.PI) / 180;

            if (toeInRadians === 0) {
                setDistance(Infinity);
            } else {
                const initialDistance = (baseline/2) / Math.tan(toeInRadians);
                if (isFinite(initialDistance) && initialDistance > 0) {
                    setDistance(initialDistance);
                }
            }

            updateValues();
        } finally {
            isUpdating = false;
        }
    }

    function syncValues(id) {
        if (isUpdating) return;
        isUpdating = true;

        try {
            const range = document.getElementById(id);
            const number = document.getElementById(id + 'Value');
            let value;

            // Add input validation
            if (!range || !number) {
                throw new Error(`Missing input elements for ${id}`);
            }

            // Validate numerical input
            value = parseFloat(number.value);
            if (isNaN(value)) {
                value = parseFloat(range.value);
                number.value = value;
            }

            value = Math.min(Math.max(value, parseFloat(range.min)), parseFloat(range.max));
            range.value = value;
            // Determine which element triggered the event
            const sourceElement = document.activeElement;
            if (sourceElement === number) {
                value = parseFloat(number.value);
                if (!isNaN(value)) {
                    value = Math.min(Math.max(value, parseFloat(range.min)), parseFloat(range.max));
                    range.value = value;
                    number.value = value;
                }
            } else {
                value = parseFloat(range.value);
                number.value = value;
            }

            updateLabel(id);

            // Handle parameter updates
            switch(id) {
                case 'toeInAngle':
                    if (!isNaN(value)) {
                        const baseline = parseFloat(document.getElementById('baselineValue').value) / 1000;
                        const toeInRadians = (value * Math.PI) / 180;

                        if (toeInRadians === 0) {
                            setDistance(Infinity);
                        } else {
                            const newDistance = (baseline/2) / Math.tan(toeInRadians);
                            if (isFinite(newDistance) && newDistance > 0) {
                                setDistance(newDistance);
                            }
                        }
                    }
                    break;

                case 'baseline':
                    if (!isNaN(value)) {
                        const baseline = value / 1000;
                        const toeInDegrees = parseFloat(document.getElementById('toeInAngleValue').value);
                        const toeInRadians = (toeInDegrees * Math.PI) / 180;

                        if (toeInRadians === 0) {
                            setDistance(Infinity);
                        } else {
                            const newDistance = (baseline/2) / Math.tan(toeInRadians);
                            if (isFinite(newDistance) && newDistance > 0) {
                                setDistance(newDistance);
                            }
                        }
                    }
                    break;

                case 'distance':
                    const distanceValue = parseFloat(number.value);
                    if (!isNaN(distanceValue) && distanceValue > 0) {
                        const baseline = parseFloat(document.getElementById('baselineValue').value) / 1000;
                        const newToeIn = Math.atan2(baseline/2, distanceValue);
                        const newToeInDegrees = (newToeIn * 180) / Math.PI;

                        if (isFinite(newToeInDegrees) && newToeInDegrees >= 0) {
                            setToeIn(newToeInDegrees);
                        }
                    } else if (distanceValue === Infinity || number.value === "∞") {
                        setToeIn(0);
                    }
                    break;
            }

            if (id === 'focalLength' || id === 'fieldOfView') {
                updateDependentValues(id);
            }

            updateValues();
        } finally {
            isUpdating = false;
        }
    }

    function setDistance(value) {
        const distanceInput = document.getElementById('distance');
        const distanceValue = document.getElementById('distanceValue');
        const distanceLabel = document.getElementById('distanceLabel');

        // Add null checks before accessing the elements
        if (!distanceInput || !distanceValue || !distanceLabel) {
            console.error('Missing distance input elements');
            return;
        }

        if (value === Infinity || !isFinite(value) || value <= 0) {
            distanceInput.value = distanceInput.max; // Set to max range value
            distanceValue.value = "∞";
            distanceLabel.textContent = "∞";
        } else {
            const displayValue = value.toFixed(2);
            distanceInput.value = Math.min(value, distanceInput.max);
            distanceValue.value = displayValue;
            distanceLabel.textContent = displayValue;
        }
    }

    function setToeIn(value) {
        const toeInInput = document.getElementById('toeInAngle');
        const toeInValue = document.getElementById('toeInAngleValue');
        const toeInLabel = document.getElementById('toeInAngleLabel');

        if (!isFinite(value) || value < 0) {
            value = 0;
        }

        const displayValue = value.toFixed(3);
        toeInInput.value = value;
        toeInValue.value = displayValue;
        toeInLabel.textContent = displayValue;
    }

    function updateLabel(id) {
        const value = document.getElementById(id).value;
        const label = document.getElementById(`${id}Label`);
        if (label) {
            label.textContent = value === "∞" ? "∞" : value;
        }
    }

    // Add event listener for page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeValues();
    });

    function updateDependentValues(changedId) {
        const sensorWidth = parseFloat(document.getElementById('sensorWidth').value);

        if (changedId === 'focalLength') {
            const focalLength = parseFloat(document.getElementById('focalLength').value);
            const fieldOfView = (2 * Math.atan(sensorWidth / (2 * focalLength)) * 180) / Math.PI;
            document.getElementById('fieldOfView').value = fieldOfView.toFixed(1);
            document.getElementById('fieldOfViewValue').value = fieldOfView.toFixed(1);
        } else if (changedId === 'fieldOfView') {
            const fieldOfView = parseFloat(document.getElementById('fieldOfView').value);
            const focalLength = sensorWidth / (2 * Math.tan((fieldOfView * Math.PI) / 360));
            document.getElementById('focalLength').value = focalLength.toFixed(2);
            document.getElementById('focalLengthValue').value = focalLength.toFixed(2);
        }
    }


  function updateValues() {
    const elements = {
        sensorWidth: document.getElementById("sensorWidth"),
        focalLength: document.getElementById("focalLength"),
        baseline: document.getElementById("baseline"),
        fieldOfView: document.getElementById("fieldOfView"),
        distance: document.getElementById("distance"),
        toeInAngle: document.getElementById("toeInAngle")
    };

    // Check if all elements exist
    for (const [key, element] of Object.entries(elements)) {
        if (!element) {
            console.error(`Missing element: ${key}`);
            return;
        }
    }

    const sensorWidth = parseFloat(elements.sensorWidth.value);
    const focalLength = parseFloat(elements.focalLength.value);
    const baseline = parseFloat(elements.baseline.value) / 1000; // mm to meters
    const fieldOfView = parseFloat(elements.fieldOfView.value);
    const distance = parseFloat(elements.distance.value);
    const toeInAngle = parseFloat(elements.toeInAngle.value);
    const toeInRadians = (toeInAngle * Math.PI) / 180;

    // Calculate values with infinity handling
    const focalLengthPixels = (focalLength / sensorWidth) * 2592;

    // Minimum Depth Resolution (zmin)
    const zmin = baseline / (2 * Math.tan(toeInRadians + (fieldOfView * Math.PI / 360)));

    // Disparity calculation with infinity handling
    let disparity;
    if (!isFinite(distance) || distance <= 0) {
        disparity = 0;
    } else {
        disparity = (focalLengthPixels * baseline) / (distance * Math.cos(toeInRadians));
    }

    // Depth Resolution calculation
    let depthResolution;
    if (!isFinite(distance) || distance <= 0) {
        depthResolution = Infinity;
    } else {
        depthResolution = (distance * distance) / (focalLengthPixels * baseline);
    }

    // Maximum Depth Resolution (zmax)
    const theta = 175e-6; // Pixel angular resolution in radians
    const zmax = baseline / (theta * Math.cos(toeInRadians));

    // Format display values with infinity handling
    function formatValue(value, decimals = 2) {
        if (!isFinite(value)) {
            return "∞";
        } else if (isNaN(value)) {
            return "undefined";
        } else if (value < 0) {
            return "invalid";
        } else {
            return value.toFixed(decimals);
        }
    }

    // Update the results in the UI with formatted values
    document.getElementById('focalLengthPixels').textContent =
        `Focal Length (px): ${formatValue(focalLengthPixels)}`;
    document.getElementById('disparity').textContent =
        `Disparity: ${formatValue(disparity)} px`;
    document.getElementById('zmin').textContent =
        `Minimum Depth Resolution (zmin): ${formatValue(zmin)} m`;
    document.getElementById('zmax').textContent =
        `Maximum Depth Resolution (zmax): ${formatValue(zmax)} m`;
    document.getElementById('convergencePoint').textContent =
        `Convergence Point (zconvergence): ${formatValue(distance)} m`;

    // Update depth resolution display (convert to mm for smaller values)
    const depthResolutionMM = depthResolution * 1000;
    document.getElementById("depthResolution").textContent =
        `Depth Resolution at Distance: ${formatValue(depthResolutionMM)} mm`;

    // Only update visualization if values are valid
    if (isFinite(baseline) && isFinite(distance) && isFinite(fieldOfView) && isFinite(toeInRadians)) {
        updateSvg(baseline, distance, fieldOfView, toeInRadians);
    }
}



 function updateSvg(baseline, distance, fieldOfView, toeInAngle) {
    const svg = document.getElementById("cameraView");
    const scalingFactor = 50; // 100 pixels = 1 meter
    const maxYLimitMeters = 10; // Set Y-axis max limit at 10 meters
    const maxYPixels = maxYLimitMeters * scalingFactor;

    const sideLength = maxYPixels * 2; // Double Y-axis for symmetry

    // Adjust SVG size with fixed Y max limit
    svg.setAttribute("viewBox", `-${sideLength / 2} -${maxYPixels+400} ${sideLength} ${(maxYPixels * 2)-100}`);
    svg.setAttribute("width", sideLength);
    svg.setAttribute("height", maxYPixels * 2);

    const baselinePixels = baseline * scalingFactor;
    const leftCameraX = -baselinePixels / 2;
    const rightCameraX = baselinePixels / 2;
    const centerY = 0; // Camera Y position
    const distancePixels = Math.min(distance * scalingFactor, maxYPixels); // Limit distance visualization to max Y

    // Clear old ticks
    document.querySelectorAll(".tick").forEach(tick => tick.remove());

    // Add Y-axis ticks within the max Y range
    const yAxisInterval = scalingFactor; // 1 meter per tick
    for (let y = -maxYPixels; y <= maxYPixels; y += yAxisInterval) {
        const yTick = document.createElementNS("http://www.w3.org/2000/svg", "line");
        yTick.setAttribute("x1", -5);
        yTick.setAttribute("y1", y);
        yTick.setAttribute("x2", 5);
        yTick.setAttribute("y2", y);
        yTick.setAttribute("stroke", "black");
        yTick.setAttribute("stroke-width", "1");
        yTick.setAttribute("class", "tick");
        svg.appendChild(yTick);

        const yLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
        yLabel.setAttribute("x", -20);
        yLabel.setAttribute("y", y + 5);
        yLabel.setAttribute("text-anchor", "end");
        yLabel.setAttribute("font-size", "18");
        yLabel.setAttribute("class", "tick");
        yLabel.textContent = (-y / scalingFactor).toFixed(1);
        svg.appendChild(yLabel);
    }

    // Draw axes
    document.getElementById("xAxis").setAttribute("x1", -sideLength / 2);
    document.getElementById("xAxis").setAttribute("y1", 0);
    document.getElementById("xAxis").setAttribute("x2", sideLength / 2);
    document.getElementById("xAxis").setAttribute("y2", 0);

    document.getElementById("yAxis").setAttribute("x1", 0);
    document.getElementById("yAxis").setAttribute("y1", -sideLength / 2);
    document.getElementById("yAxis").setAttribute("x2", 0);
    document.getElementById("yAxis").setAttribute("y2", sideLength / 2);

    // Add axis labels
    document.getElementById("xAxisLabel").setAttribute("x", sideLength / 2 - 40);
    document.getElementById("xAxisLabel").setAttribute("y", 20);
    document.getElementById("xAxisLabel").textContent = "X (m)";

    document.getElementById("yAxisLabel").setAttribute("x", -20);
    document.getElementById("yAxisLabel").setAttribute("y", -sideLength / 2 + 20);
    document.getElementById("yAxisLabel").textContent = "Y (m)";

    // Convert toe-in angles to radians
    const leftToeInRadians = toeInAngle;
    const rightToeInRadians = -toeInAngle; // Symmetrical toe-in for the right camera

    // Optical axis lengths (extend these lines from the cameras)
    const opticalAxisLength = distancePixels * 1.5;

    // Calculate endpoints for the blue lines (optical axes)
    const leftOpticalAxisX = leftCameraX + Math.sin(leftToeInRadians) * opticalAxisLength;
    const leftOpticalAxisY = centerY - Math.cos(leftToeInRadians) * opticalAxisLength;

    const rightOpticalAxisX = rightCameraX + Math.sin(rightToeInRadians) * opticalAxisLength;
    const rightOpticalAxisY = centerY - Math.cos(rightToeInRadians) * opticalAxisLength;

    // Draw the optical axes (blue lines)
    document.getElementById("leftLineToObject").setAttribute("x1", leftCameraX);
    document.getElementById("leftLineToObject").setAttribute("y1", centerY);
    document.getElementById("leftLineToObject").setAttribute("x2", leftOpticalAxisX);
    document.getElementById("leftLineToObject").setAttribute("y2", leftOpticalAxisY);

    document.getElementById("rightLineToObject").setAttribute("x1", rightCameraX);
    document.getElementById("rightLineToObject").setAttribute("y1", centerY);
    document.getElementById("rightLineToObject").setAttribute("x2", rightOpticalAxisX);
    document.getElementById("rightLineToObject").setAttribute("y2", rightOpticalAxisY);

    // Draw the object point (for reference)
    const objectX = 0; // World origin for simplicity
    const objectY = -distancePixels;
    document.getElementById("objectPoint").setAttribute("cx", objectX);
    document.getElementById("objectPoint").setAttribute("cy", objectY);

    // Adjust FOV polygons based on toe-in angles
    const fovRadians = (fieldOfView * Math.PI) / 180;
    const fovHalfWidth = Math.tan(fovRadians / 2) * distancePixels;

    const leftFOVPoints = `
        ${leftCameraX},${centerY}
        ${leftCameraX + Math.sin(leftToeInRadians) * distancePixels - fovHalfWidth},${centerY - Math.cos(leftToeInRadians) * distancePixels}
        ${leftCameraX + Math.sin(leftToeInRadians) * distancePixels + fovHalfWidth},${centerY - Math.cos(leftToeInRadians) * distancePixels}
    `;

    const rightFOVPoints = `
        ${rightCameraX},${centerY}
        ${rightCameraX + Math.sin(rightToeInRadians) * distancePixels - fovHalfWidth},${centerY - Math.cos(rightToeInRadians) * distancePixels}
        ${rightCameraX + Math.sin(rightToeInRadians) * distancePixels + fovHalfWidth},${centerY - Math.cos(rightToeInRadians) * distancePixels}
    `;

    document.getElementById("leftCameraFOV").setAttribute("points", leftFOVPoints);
    document.getElementById("rightCameraFOV").setAttribute("points", rightFOVPoints);

    // Draw the baseline between the two cameras
    document.getElementById("baselineLine").setAttribute("x1", leftCameraX);
    document.getElementById("baselineLine").setAttribute("y1", centerY);
    document.getElementById("baselineLine").setAttribute("x2", rightCameraX);
    document.getElementById("baselineLine").setAttribute("y2", centerY);

    // Draw axes
    document.getElementById("xAxis").setAttribute("x1", -sideLength / 2);
    document.getElementById("xAxis").setAttribute("y1", 0);
    document.getElementById("xAxis").setAttribute("x2", sideLength / 2);
    document.getElementById("xAxis").setAttribute("y2", 0);

    document.getElementById("yAxis").setAttribute("x1", 0);
    document.getElementById("yAxis").setAttribute("y1", -sideLength / 2);
    document.getElementById("yAxis").setAttribute("x2", 0);
    document.getElementById("yAxis").setAttribute("y2", sideLength / 2);

    // Add axis labels
    document.getElementById("xAxisLabel").setAttribute("x", sideLength / 2 - 40);
    document.getElementById("xAxisLabel").setAttribute("y", 20);
    document.getElementById("xAxisLabel").textContent = "X (m)";

    document.getElementById("yAxisLabel").setAttribute("x", -20);
    document.getElementById("yAxisLabel").setAttribute("y", -sideLength / 2 + 20);
    document.getElementById("yAxisLabel").textContent = "Y (m)";

}




    updateValues();
</script>
</body>
</html>
